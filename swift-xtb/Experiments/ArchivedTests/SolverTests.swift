import XCTest
import Mechanosynthesis
import Numerics

// A set of tests for solving the 3D potential generated by a nucleus.
final class SolverTests: XCTestCase {
  // First, check the solution from the direct matrix method. Make the domain
  // small enough that the direct method executes in ~1 ms. It may be too small
  // to observe a significant speedup from multigrid relaxations, but that is
  // okay. We only need code for a multigrid that works at all.
  func testDirectMatrixMethod() throws {
    // The problem size is the number of cells, plus 6 variables for boundary
    // conditions imposed on each cell. To align the matrix rows to the CPU
    // vector width, we pad the number 6 to 8.
    let n = Self.cellCount + 8
    
    // Allocate a matrix and two vectors.
    var potential = [Float](repeating: .zero, count: n)
    var rightHandSide = [Float](repeating: .zero, count: n)
    
    // Set the 7 extraneous variables to the identity. These variables
    // adapt the boundary conditions to the functional form of a
    // matrix operator.
    for constraintID in Self.cellCount..<Self.cellCount + 7 {
      potential[constraintID] = 1
      rightHandSide[constraintID] = 1
    }
    
    // The left-hand side must be fixed at 1 to impose the constraint.
    // The right-hand side must reflect the RHS of the constraint equation.
    potential[n - 1] = 1
    rightHandSide[n - 1] = 0
    
    let laplacian = Self.createLaplacianMatrix()
    
    // MARK: - Solve the equation in forward mode (LHS -> RHS)
    
    // Set the potential vector. Here, we're solving the equation in forward
    // mode. This is to check that the correct charge distribution will be
    // associated with the potential.
    for indexZ in 0..<Self.gridSize {
      for indexY in 0..<Self.gridSize {
        for indexX in 0..<Self.gridSize {
          // Compute the center of the cell.
          let cellCenterX = (Float(indexX) + 0.5) * Self.h
          let cellCenterY = (Float(indexY) + 0.5) * Self.h
          let cellCenterZ = (Float(indexZ) + 0.5) * Self.h
          let cellCenter = SIMD3<Float>(cellCenterX, cellCenterY, cellCenterZ)
          
          // Place the nucleus at the midpoint of the 3D grid.
          let gridWidth = Float(Self.gridSize) * Self.h
          let nucleusPosition = 0.5 * SIMD3(repeating: gridWidth)
          
          // Find the distance and direction from the nucleus.
          let rDelta = cellCenter - nucleusPosition
          let distance = (rDelta * rDelta).sum().squareRoot()
          
          // Compute the potential generated by a hydrogen nucleus.
          let φ = Float(1) / distance
          
          // Write the peotential to memory.
          var cellID = indexZ * (Self.gridSize * Self.gridSize)
          cellID += indexY * Self.gridSize + indexX
          potential[cellID] = φ
        }
      }
    }
    
    // Multiply the Laplacian by the potential, creating the charge density.
    for rowID in 0..<n {
      var accumulator: Float = .zero
      for columnID in 0..<n {
        // Fetch a value from the Laplacian.
        let lhs = laplacian[rowID * n + columnID]
        
        // Fetch a value from the potential.
        let rhs = potential[columnID]
        
        // Multiply and accumulate in FP32.
        accumulator += lhs * rhs
      }
      
      // Write the dot product to the right-hand side.
      rightHandSide[rowID] = accumulator
    }
    
    // Sum the charge predicted by the matrix solution.
    do {
      var accumulator: Double = .zero
      for cellID in 0..<Self.cellCount {
        let ρ = rightHandSide[cellID] / (-4 * Float.pi)
        let drTerm = Self.h * Self.h * Self.h
        accumulator += Double(ρ * drTerm)
      }
      
      // The net charge should match the hydrogen nucleus, with one proton.
      let charge = Float(accumulator)
      XCTAssertEqual(charge, 1, accuracy: 1e-3)
    }
    
    // Check that the constraint variables are set to 1.
    for constraintID in Self.cellCount..<Self.cellCount + 8 {
      let rhsValue = rightHandSide[constraintID]
      XCTAssertEqual(rhsValue, 1, accuracy: 1e-3)
    }
    
    // MARK: - Solve the equation in reverse mode (RHS -> LHS)
    
    // Set the right-hand side to -4π times the charge density.
    for cellID in 0..<Self.cellCount {
      rightHandSide[cellID] = .zero
    }
    rightHandSide[n - 1] = .zero
    for permutationZ in -1...0 {
      for permutationY in -1...0 {
        for permutationX in -1...0 {
          var indices = SIMD3(repeating: Self.gridSize / 2)
          indices[0] += permutationX
          indices[1] += permutationY
          indices[2] += permutationZ
          
          // Place 1/8 of the charge density in each of the 8 cells.
          let chargeEnclosed: Float = 1.0 / 8
          let chargeDensity = chargeEnclosed / (Self.h * Self.h * Self.h)
          
          // Multiply -4π with ρ, resulting in -4πρ.
          let rhsValue = (-4 * Float.pi) * chargeDensity
          
          // Write the right-hand side to memory.
          var cellID = indices.z * (Self.gridSize * Self.gridSize)
          cellID += indices.y * Self.gridSize + indices.x
          rightHandSide[cellID] = rhsValue
        }
      }
    }
    
    // Solve the linear equation.
    //
    // Something interesting happens. The potential is shifted by a constant
    // value. However, the absolute value of potential energy is always
    // arbitrary. I wonder whether it's possible to force the potential to
    // agree with the numerical value. Perhaps if the boundary conditions are
    // Dirichlet boundary conditions, at the lowest level of the multigrid.
    let analyticalPotential = potential
    let numericalPotential = LinearAlgebraUtilities.solveLinearSystem(
      matrix: laplacian, vector: rightHandSide, n: n)
    
    let dirichletConditions = Self.createBoundaryConditions(type: .dirichlet)
    let neumannConditions = Self.createBoundaryConditions(type: .neumann)
    
    for cellID in 0..<Self.cellCount {
      print(
        analyticalPotential[cellID],
        numericalPotential[cellID],
        numericalPotential[cellID] - analyticalPotential[cellID],
        rightHandSide[cellID] / (-4 * Float.pi),
        terminator: " ")
      
      let facePotentials = dirichletConditions[cellID]
      print("| φ =", terminator: " ")
      for faceID in 0..<6 {
        let potential = facePotentials[faceID]
        if potential != .zero {
          print(potential, terminator: " ")
        }
      }
      
      let faceFluxes = neumannConditions[cellID]
      print("| F =", terminator: " ")
      for faceID in 0..<6 {
        let flux = faceFluxes[faceID]
        if flux != .zero {
          print(flux, terminator: " ")
        }
      }
      
      print()
    }
    
    for cellID in Self.cellCount..<Self.cellCount + 8 {
      print(analyticalPotential[cellID], numericalPotential[cellID], rightHandSide[cellID])
    }
  }
  
  // Implementation of the algorithm from the INQ codebase, which chooses the
  // timestep based on the results of some integrals.
  func testSteepestDescent() throws {
    
  }
  
  // Implementation of weighted Jacobi, using a fixed timestep determined by
  // the grid spacing.
  func testWeightedJacobi() throws {
    
  }
  
  // Implementation of Gauss-Seidel, using a fixed timestep determined by the
  // grid spacing.
  //
  // This test does not cover the Gauss-Seidel red-black ordering scheme.
  // However, the results should reveal how one would go about coding GSRB.
  func testGaussSeidel() throws {
    
  }
  
  // Implementation of the algorithm from the INQ codebase, which chooses the
  // timestep based on the results of some integrals.
  func testConjugateGradient() throws {
    
  }
  
  // Multigrid solver. There's currently a big unknown regarding how the grid
  // should treat domain boundaries.
  func testMultigrid() throws {
    
  }
}
